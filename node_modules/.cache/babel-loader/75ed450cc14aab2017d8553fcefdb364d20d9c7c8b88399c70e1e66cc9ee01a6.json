{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ibrahim/Desktop/Glob_az-CargoShippingCompany-main/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ibrahim/Desktop/Glob_az-CargoShippingCompany-main/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar IntervalState;\n(function (IntervalState) {\n  IntervalState[IntervalState[\"IDLE\"] = 0] = \"IDLE\";\n  IntervalState[IntervalState[\"RUNNING\"] = 1] = \"RUNNING\";\n  IntervalState[IntervalState[\"PAUSED\"] = 2] = \"PAUSED\";\n  IntervalState[IntervalState[\"RESUME\"] = 3] = \"RESUME\";\n})(IntervalState || (IntervalState = {}));\n/**\n * `IntervalTimer` is a class that handles logic for intervals, e.g. start stop, reset, resume, pause & maximum amount of fires.\n */\nvar IntervalTimer = /*#__PURE__*/function () {\n  function IntervalTimer(\n  /**\n   * Called after every interval.\n   */\n  callback,\n  /**\n   * Time between intervals, in milliseconds.\n   */\n  interval,\n  /**\n   * Maximum amount of fires.\n   */\n  maxFires) {\n    var _this = this;\n    _classCallCheck(this, IntervalTimer);\n    this.callback = callback;\n    this.interval = interval;\n    this.maxFires = maxFires;\n    /**\n     * The state to handle logic.\n     * - 0 means the interval is idle.\n     * - 1 means it's running.\n     * - 2 means it's paused\n     * - 3 will resume.\n     */\n    this.state = IntervalState.IDLE;\n    /**\n     * Remaining time before the next interval.\n     */\n    this.remaining = 0;\n    /**\n     * Amount of times fired.\n     */\n    this.fires = 0;\n    /**\n     * Time passed after pausing,\n     */\n    this.pausedTime = 0;\n    /**\n     * Handles the callback execution, the amount of fires, & the times when fired.\n     * If `this.maxFires` is **not** null, and it's bigger than `this.fires` and if `this.fires` exists, meaning if it the interval was at least started once before, then never fire again.\n     */\n    this.intervalHandler = function () {\n      if (_this.maxFires != null && _this.fires !== 0 && _this.fires >= _this.maxFires) {\n        _this.stop();\n      } else {\n        _this.lastTimeFired = new Date();\n        _this.fires += 1;\n        _this.callback();\n      }\n    };\n    /**\n     * `timeoutHandler` is executed by `resume`. `timeoutHandler` is the callback of a new `setTimeout` executed by `resume` to mimic a resume function.\n     * The callback is executed by running `intervalHandler`, and then `start` is executed to run a new interval.\n     */\n    this.timeoutHandler = function () {\n      if (_this.state !== IntervalState.RESUME) return;\n      _this.pausedTime = 0;\n      _this.intervalHandler();\n      _this.start();\n    };\n    /**\n     * `start` executes the interval, and saves the interval ID for further use.\n     * The time of execution is also fired in case it's paused later on. The state\n     * is finally set as running.\n     */\n    this.start = function () {\n      _this.timerId = setInterval(_this.intervalHandler, _this.interval);\n      _this.lastTimeFired = new Date();\n      _this.state = IntervalState.RUNNING;\n    };\n    /**\n     * `stop` clears every respective timeout and interval, then sets the state as idle.\n     */\n    this.stop = function () {\n      if (_this.state === 0) return;\n      clearInterval(_this.timerId);\n      clearTimeout(_this.resumeId);\n      _this.state = IntervalState.IDLE;\n    };\n    /**\n     * Resets the interval.\n     */\n    this.reset = function () {\n      _this.stop();\n      _this.start();\n    };\n    /**\n     * `pause` tries to mimic pausing the interval by calculating the remaining time and storing it\n     * in a member variable. Afterwards clear the respective timeout and interval then set the new\n     * state.\n     */\n    this.pause = function () {\n      if (_this.state !== IntervalState.RUNNING && _this.state !== IntervalState.RESUME) return;\n      _this.remaining = +_this.interval - (+new Date() - +(_this.lastTimeFired || 0)) + +_this.pausedTime;\n      _this.lastPauseTime = new Date();\n      clearInterval(_this.timerId);\n      clearTimeout(_this.resumeId);\n      _this.state = IntervalState.PAUSED;\n    };\n    /**\n     * `resume` calculates the remaining time for the callback to trigger using the values\n     * set by `paused`. Will execute a new `setTimeout` while passing the `remaining` time\n     * as the timeout delay.\n     */\n    this.resume = function () {\n      if (_this.state !== IntervalState.PAUSED) return;\n      var currentDate = new Date();\n      _this.pausedTime = +_this.pausedTime + +currentDate - +(_this.lastPauseTime || 0);\n      _this.state = IntervalState.RESUME;\n      _this.resumeId = setTimeout(_this.timeoutHandler, _this.remaining);\n    };\n    /**\n     * Set a new interval to use on the next interval loop.\n     */\n    this.setInterval = function (newInterval) {\n      if (_this.state === 1) {\n        // If running we need to instantiate (new ID) the variable.\n        _this.pause();\n        _this.interval = newInterval;\n        _this.resume();\n      } else {\n        // If stopped, idle, or paused then switch it.\n        _this.interval = newInterval;\n      }\n    };\n    /**\n     * Maximum amount of times the `callback` member will execute, it's infinite by default.\n     */\n    this.setMaxFires = function (newMax) {\n      if (newMax != null && _this.fires >= newMax) {\n        _this.stop();\n      }\n      _this.maxFires = newMax;\n    };\n  }\n  _createClass(IntervalTimer, null, [{\n    key: \"new\",\n    value: function _new(callback, interval) {\n      var maxFires = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      if (!this.instance) this.instance = new IntervalTimer(callback, interval, maxFires);else {\n        this.instance.callback = callback;\n        this.instance.interval = interval;\n        this.instance.maxFires = maxFires;\n      }\n      return this.instance;\n    }\n  }]);\n  return IntervalTimer;\n}();\nexport { IntervalState, IntervalTimer as default };","map":{"version":3,"mappings":"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","names":["IntervalState","IntervalTimer","callback","interval","maxFires","IDLE","fires","stop","lastTimeFired","Date","state","RESUME","pausedTime","intervalHandler","start","timerId","setInterval","RUNNING","clearInterval","clearTimeout","resumeId","remaining","lastPauseTime","PAUSED","currentDate","setTimeout","timeoutHandler","newInterval","pause","resume","newMax","undefined","instance"],"sources":["C:\\Users\\Ibrahim\\Desktop\\Glob_az-CargoShippingCompany-main\\node_modules\\hero-slider\\src\\modules\\IntervalTimer.ts"],"sourcesContent":["export enum IntervalState {\n  IDLE,\n  RUNNING,\n  PAUSED,\n  RESUME\n}\n\n/**\n * `IntervalTimer` is a class that handles logic for intervals, e.g. start stop, reset, resume, pause & maximum amount of fires.\n */\nexport default class IntervalTimer {\n  /**\n   * The state to handle logic.\n   * - 0 means the interval is idle.\n   * - 1 means it's running.\n   * - 2 means it's paused\n   * - 3 will resume.\n   */\n  public state: IntervalState = IntervalState.IDLE;\n\n  /**\n   * Remaining time before the next interval.\n   */\n  public remaining: number = 0;\n\n  /**\n   * Amount of times fired.\n   */\n  public fires: number = 0;\n\n  /**\n   * Time passed after pausing,\n   */\n  public pausedTime: number | Date = 0;\n\n  private lastTimeFired?: Date;\n  private timerId?: NodeJS.Timer;\n  private resumeId?: NodeJS.Timeout;\n  private lastPauseTime?: Date;\n\n  private constructor(\n    /**\n     * Called after every interval.\n     */\n    public callback: () => void,\n    /**\n     * Time between intervals, in milliseconds.\n     */\n    public interval: number,\n    /**\n     * Maximum amount of fires.\n     */\n    public maxFires?: number\n  ) {}\n\n  /**\n   * Handles the callback execution, the amount of fires, & the times when fired.\n   * If `this.maxFires` is **not** null, and it's bigger than `this.fires` and if `this.fires` exists, meaning if it the interval was at least started once before, then never fire again.\n   */\n  private intervalHandler = () => {\n    if (\n      this.maxFires != null &&\n      this.fires !== 0 &&\n      this.fires >= this.maxFires\n    ) {\n      this.stop();\n    } else {\n      this.lastTimeFired = new Date();\n      this.fires += 1;\n      this.callback();\n    }\n  };\n\n  /**\n   * `timeoutHandler` is executed by `resume`. `timeoutHandler` is the callback of a new `setTimeout` executed by `resume` to mimic a resume function.\n   * The callback is executed by running `intervalHandler`, and then `start` is executed to run a new interval.\n   */\n  private timeoutHandler = () => {\n    if (this.state !== IntervalState.RESUME) return;\n\n    this.pausedTime = 0;\n    this.intervalHandler();\n    this.start();\n  };\n\n  /**\n   * `start` executes the interval, and saves the interval ID for further use.\n   * The time of execution is also fired in case it's paused later on. The state\n   * is finally set as running.\n   */\n  public start = () => {\n    this.timerId = setInterval(this.intervalHandler, this.interval);\n    this.lastTimeFired = new Date();\n    this.state = IntervalState.RUNNING;\n  };\n\n  /**\n   * `stop` clears every respective timeout and interval, then sets the state as idle.\n   */\n  public stop = () => {\n    if (this.state === 0) return;\n\n    clearInterval(this.timerId);\n    clearTimeout(this.resumeId);\n    this.state = IntervalState.IDLE;\n  };\n\n  /**\n   * Resets the interval.\n   */\n  public reset = () => {\n    this.stop();\n    this.start();\n  };\n\n  /**\n   * `pause` tries to mimic pausing the interval by calculating the remaining time and storing it\n   * in a member variable. Afterwards clear the respective timeout and interval then set the new\n   * state.\n   */\n  public pause = () => {\n    if (\n      this.state !== IntervalState.RUNNING &&\n      this.state !== IntervalState.RESUME\n    )\n      return;\n\n    this.remaining =\n      +this.interval -\n      (+new Date() - +(this.lastTimeFired || 0)) +\n      +this.pausedTime;\n    this.lastPauseTime = new Date();\n    clearInterval(this.timerId);\n    clearTimeout(this.resumeId);\n    this.state = IntervalState.PAUSED;\n  };\n\n  /**\n   * `resume` calculates the remaining time for the callback to trigger using the values\n   * set by `paused`. Will execute a new `setTimeout` while passing the `remaining` time\n   * as the timeout delay.\n   */\n  public resume = () => {\n    if (this.state !== IntervalState.PAUSED) return;\n    const currentDate = new Date();\n    this.pausedTime =\n      +this.pausedTime + +currentDate - +(this.lastPauseTime || 0);\n    this.state = IntervalState.RESUME;\n    this.resumeId = setTimeout(this.timeoutHandler, this.remaining);\n  };\n\n  /**\n   * Set a new interval to use on the next interval loop.\n   */\n  public setInterval = (newInterval: number) => {\n    if (this.state === 1) {\n      // If running we need to instantiate (new ID) the variable.\n      this.pause();\n      this.interval = newInterval;\n      this.resume();\n    } else {\n      // If stopped, idle, or paused then switch it.\n      this.interval = newInterval;\n    }\n  };\n\n  /**\n   * Maximum amount of times the `callback` member will execute, it's infinite by default.\n   */\n  public setMaxFires = (newMax: number) => {\n    if (newMax != null && this.fires >= newMax) {\n      this.stop();\n    }\n    this.maxFires = newMax;\n  };\n\n  private static instance: IntervalTimer | undefined;\n\n  public static new(\n    callback: () => void,\n    interval: number,\n    maxFires: number | undefined = undefined\n  ): IntervalTimer {\n    if (!this.instance)\n      this.instance = new IntervalTimer(callback, interval, maxFires);\n    else {\n      this.instance.callback = callback;\n      this.instance.interval = interval;\n      this.instance.maxFires = maxFires;\n    }\n    return this.instance;\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}