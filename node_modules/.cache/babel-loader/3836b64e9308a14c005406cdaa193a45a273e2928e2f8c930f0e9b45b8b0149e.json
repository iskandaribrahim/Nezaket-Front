{"ast":null,"code":"import _slicedToArray from \"C:/Users/Ibrahim/Desktop/Glob_az-CargoShippingCompany-main/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport React__default from 'react';\nimport IntervalTimer, { IntervalState } from './IntervalTimer.js';\nimport { useController } from './Controller.js';\nimport { useIntersectionObserver } from './IntersectionObserver.js';\nimport ConsoleLogger from './ConsoleLogger.js';\nvar logger = ConsoleLogger.new();\nvar defaultProps = {\n  autoplayDuration: 8000,\n  autoplayDebounce: 4000\n};\nvar AutoplayStateContext = React__default.createContext(undefined);\nfunction autoplayReducer(state, action) {\n  switch (action.type) {\n    case 'pause':\n      {\n        return Object.assign(Object.assign({}, state), {\n          isPausedByUser: true\n        });\n      }\n    case 'resume':\n      {\n        return Object.assign(Object.assign({}, state), {\n          isPausedByUser: false\n        });\n      }\n    case 'set-debounce-timeout':\n      {\n        return Object.assign(Object.assign({}, state), {\n          debounceTimeout: action.payload\n        });\n      }\n    default:\n      {\n        throw new Error(\"Unhandled action: [\".concat(JSON.stringify(action, null, 2), \"]\"));\n      }\n  }\n}\nfunction AutoplayProvider(_ref) {\n  var children = _ref.children,\n    autoplay = _ref.autoplay;\n  var _a, _b;\n  var params = {\n    autoplayDuration: (_a = typeof autoplay === 'object' ? autoplay === null || autoplay === void 0 ? void 0 : autoplay.autoplayDuration : undefined) !== null && _a !== void 0 ? _a : defaultProps.autoplayDuration,\n    autoplayDebounce: (_b = typeof autoplay === 'object' ? autoplay === null || autoplay === void 0 ? void 0 : autoplay.autoplayDebounce : undefined) !== null && _b !== void 0 ? _b : defaultProps.autoplayDebounce\n  };\n  var _React__default$useRe = React__default.useReducer(autoplayReducer, {\n      isPausedByUser: false,\n      debounceTimeout: undefined\n    }),\n    _React__default$useRe2 = _slicedToArray(_React__default$useRe, 2),\n    state = _React__default$useRe2[0],\n    dispatch = _React__default$useRe2[1];\n  var _useController = useController(),\n    controller = _useController.state,\n    changeSlide = _useController.changeSlide,\n    getNextSlide = _useController.getNextSlide,\n    getSlidingCycleDuration = _useController.getSlidingCycleDuration;\n  var slidingCycleDuration = getSlidingCycleDuration();\n  var autoplayCycleDuration = Math.max(slidingCycleDuration, params.autoplayDuration);\n  if (params.autoplayDuration < getSlidingCycleDuration()) logger.warn('[Autoplay] The `autoplayDuration` is lower than the sliding cycle duration (the result of `slidingDuration + slidingDelay`).', 'The sliding cycle duration will be used instead for the autoplay intervals.');\n  var autoplayInstance = IntervalTimer.new(function () {\n    changeSlide(getNextSlide(controller.activeSlide));\n  }, autoplayCycleDuration);\n  var _useIntersectionObser = useIntersectionObserver(),\n    isInView = _useIntersectionObser.isInView;\n  /**\n   * Debounces the autoplay interval whene called.\n   */\n  var debounce = function debounce() {\n    var isPausedOrIdle = autoplayInstance.state === IntervalState.IDLE || state.isPausedByUser;\n    if (isPausedOrIdle) return; // If the slider has been paused, do nothing.\n    autoplayInstance.pause();\n    if (state.debounceTimeout) clearTimeout(state.debounceTimeout);\n    dispatch({\n      type: 'set-debounce-timeout',\n      payload: setTimeout(autoplayInstance.resume, params.autoplayDebounce)\n    });\n  };\n  /**\n   * Pauses the autoplay.\n   */\n  var pause = function pause() {\n    logger.debug('[Autoplay] Paused by user.');\n    autoplayInstance.pause();\n    dispatch({\n      type: 'pause'\n    });\n  };\n  /**\n   * Resumes the autoplay.\n   */\n  var resume = function resume() {\n    logger.debug('[Autoplay] Resumed by user.');\n    autoplayInstance.resume();\n    dispatch({\n      type: 'resume'\n    });\n  };\n  /**\n   * When the user pauses the slider, clear any debounced timeouts.\n   */\n  React__default.useEffect(function () {\n    if (state.isPausedByUser) clearTimeout(state.debounceTimeout);\n    return function () {};\n  }, [state.isPausedByUser]);\n  /**\n   * Subscribe to changes in `autoplay` and `isInView`.\n   * If the slider goes out of the viewport, then pause the slider autoplay instance if it's not idle.\n   * If it comes back into viewport and its idle, start or resume the autoplay instance.\n   * If the autoplay is disabled, then stop.\n   */\n  React__default.useEffect(function () {\n    if (autoplay) {\n      switch (true) {\n        case state.isPausedByUser:\n          break;\n        // When not in view, stop the autoplay.\n        case !isInView && autoplayInstance.state !== IntervalState.IDLE:\n          autoplayInstance.stop();\n          logger.debug('[Autoplay] Stopped.');\n          break;\n        // When in view and idle, start it.\n        case isInView && autoplayInstance.state === IntervalState.IDLE:\n          {\n            autoplayInstance.start();\n            logger.debug('[Autoplay] Started.');\n            break;\n          }\n        // When in view and paused, resume it.\n        case isInView && autoplayInstance.state === IntervalState.PAUSED:\n          {\n            autoplayInstance.resume();\n            logger.debug('[Autoplay] Resumed.');\n            break;\n          }\n      }\n    } else if (autoplayInstance.state !== IntervalState.IDLE) {\n      autoplayInstance.stop();\n      logger.info('[Autoplay] Stopped.');\n    }\n  }, [autoplay, isInView]);\n  /**\n   * Clearing any existing timeouts to avoid memory leaks, and clear event listener.\n   */\n  React__default.useEffect(function () {\n    return function () {\n      clearTimeout(state.debounceTimeout);\n      autoplayInstance.stop();\n    };\n  }, []);\n  /**\n   * When the slide changes, clear any debounced timeouts, after the slide finishes, the\n   * autoplay resets.\n   */\n  React__default.useEffect(function () {\n    clearTimeout(state.debounceTimeout);\n    return function () {};\n  }, [controller.activeSlide]);\n  // NOTE: you *might* need to memoize this value\n  // Learn more in http://kcd.im/optimize-context\n  var value = {\n    state: state,\n    autoplayState: autoplayInstance.state,\n    debounce: debounce,\n    pause: pause,\n    resume: resume\n  };\n  return React__default.createElement(AutoplayStateContext.Provider, {\n    value: value\n  }, children);\n}\nfunction useAutoplay() {\n  var context = React__default.useContext(AutoplayStateContext);\n  if (context === undefined) {\n    throw new Error('useAutoplay must be used within a AutoplayProvider');\n  }\n  return context;\n}\nexport { AutoplayProvider, useAutoplay };","map":{"version":3,"mappings":"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","names":["logger","ConsoleLogger","new","defaultProps","autoplayDuration","autoplayDebounce","AutoplayStateContext","React","createContext","undefined","autoplayReducer","state","action","type","isPausedByUser","debounceTimeout","payload","Error","JSON","stringify","AutoplayProvider","children","autoplay","params","useReducer","dispatch","useController","controller","changeSlide","getNextSlide","getSlidingCycleDuration","slidingCycleDuration","autoplayCycleDuration","Math","max","warn","autoplayInstance","IntervalTimer","activeSlide","useIntersectionObserver","isInView","debounce","isPausedOrIdle","IntervalState","IDLE","pause","clearTimeout","setTimeout","resume","debug","useEffect","stop","start","PAUSED","info","value","autoplayState","Provider","useAutoplay","context","useContext"],"sources":["C:\\Users\\Ibrahim\\Desktop\\Glob_az-CargoShippingCompany-main\\node_modules\\hero-slider\\src\\modules\\Autoplay.tsx"],"sourcesContent":["import React from 'react';\nimport IntervalTimer, { IntervalState } from './IntervalTimer';\nimport { useController } from './Controller';\nimport { useIntersectionObserver } from './IntersectionObserver';\nimport ConsoleLogger from './ConsoleLogger';\n\nconst logger = ConsoleLogger.new();\n\ninterface Props {\n  /**\n   * Autoplay duration, interval or duration betweens slide transitions, in milliseconds.\n   * If it's lower than the sliding cycle duration (sliding duration + sliding delay), then the sliding cycle duration will be used instead.\n   * @default 8000\n   */\n  autoplayDuration?: number;\n  /**\n   * Time (in milliseconds) in which the autoplay will be debounced if the user interacts with the slider.\n   * The autoplay resumes if the user stops interacting after this duration.\n   * Set as 0 to disable this feature.\n   * @default 4000\n   */\n  autoplayDebounce?: number;\n}\n\nexport type AutoplayProps = Props | boolean;\n\ntype Action =\n  | { type: 'pause' }\n  | { type: 'resume' }\n  | { type: 'set-debounce-timeout'; payload: NodeJS.Timeout };\ninterface State {\n  isPausedByUser: boolean;\n  debounceTimeout?: NodeJS.Timeout;\n}\ntype ProviderProps = React.PropsWithChildren<{\n  autoplay?: AutoplayProps;\n}>;\n\nconst defaultProps: Required<Props> = {\n  autoplayDuration: 8000,\n  autoplayDebounce: 4000\n};\n\nconst AutoplayStateContext = React.createContext<\n  | {\n      state: State;\n      autoplayState: IntervalState;\n      debounce: () => void;\n      pause: () => void;\n      resume: () => void;\n    }\n  | undefined\n>(undefined);\n\nfunction autoplayReducer(state: State, action: Action): State {\n  switch (action.type) {\n    case 'pause': {\n      return { ...state, isPausedByUser: true };\n    }\n    case 'resume': {\n      return { ...state, isPausedByUser: false };\n    }\n    case 'set-debounce-timeout': {\n      return { ...state, debounceTimeout: action.payload };\n    }\n    default: {\n      throw new Error(`Unhandled action: [${JSON.stringify(action, null, 2)}]`);\n    }\n  }\n}\n\nfunction AutoplayProvider({ children, autoplay }: ProviderProps) {\n  const params: Required<Props> = {\n    autoplayDuration:\n      (typeof autoplay === 'object' ? autoplay?.autoplayDuration : undefined) ??\n      defaultProps.autoplayDuration,\n    autoplayDebounce:\n      (typeof autoplay === 'object' ? autoplay?.autoplayDebounce : undefined) ??\n      defaultProps.autoplayDebounce\n  };\n\n  const [state, dispatch] = React.useReducer(autoplayReducer, {\n    isPausedByUser: false,\n    debounceTimeout: undefined\n  } as State);\n\n  const {\n    state: controller,\n    changeSlide,\n    getNextSlide,\n    getSlidingCycleDuration\n  } = useController();\n\n  const slidingCycleDuration = getSlidingCycleDuration();\n\n  const autoplayCycleDuration = Math.max(\n    slidingCycleDuration,\n    params.autoplayDuration\n  );\n\n  if (params.autoplayDuration < getSlidingCycleDuration())\n    logger.warn(\n      '[Autoplay] The `autoplayDuration` is lower than the sliding cycle duration (the result of `slidingDuration + slidingDelay`).',\n      'The sliding cycle duration will be used instead for the autoplay intervals.'\n    );\n\n  const autoplayInstance = IntervalTimer.new((): void => {\n    changeSlide(getNextSlide(controller.activeSlide));\n  }, autoplayCycleDuration);\n\n  const { isInView } = useIntersectionObserver();\n\n  /**\n   * Debounces the autoplay interval whene called.\n   */\n  const debounce = (): void => {\n    const isPausedOrIdle =\n      autoplayInstance.state === IntervalState.IDLE || state.isPausedByUser;\n\n    if (isPausedOrIdle) return; // If the slider has been paused, do nothing.\n\n    autoplayInstance.pause();\n\n    if (state.debounceTimeout) clearTimeout(state.debounceTimeout);\n\n    dispatch({\n      type: 'set-debounce-timeout',\n      payload: setTimeout(autoplayInstance.resume, params.autoplayDebounce)\n    });\n  };\n\n  /**\n   * Pauses the autoplay.\n   */\n  const pause = (): void => {\n    logger.debug('[Autoplay] Paused by user.');\n    autoplayInstance.pause();\n    dispatch({ type: 'pause' });\n  };\n\n  /**\n   * Resumes the autoplay.\n   */\n  const resume = (): void => {\n    logger.debug('[Autoplay] Resumed by user.');\n    autoplayInstance.resume();\n    dispatch({ type: 'resume' });\n  };\n\n  /**\n   * When the user pauses the slider, clear any debounced timeouts.\n   */\n  React.useEffect(() => {\n    if (state.isPausedByUser) clearTimeout(state.debounceTimeout);\n    return () => {};\n  }, [state.isPausedByUser]);\n\n  /**\n   * Subscribe to changes in `autoplay` and `isInView`.\n   * If the slider goes out of the viewport, then pause the slider autoplay instance if it's not idle.\n   * If it comes back into viewport and its idle, start or resume the autoplay instance.\n   * If the autoplay is disabled, then stop.\n   */\n  React.useEffect(() => {\n    if (autoplay) {\n      switch (true) {\n        case state.isPausedByUser:\n          break;\n        // When not in view, stop the autoplay.\n        case !isInView && autoplayInstance.state !== IntervalState.IDLE:\n          autoplayInstance.stop();\n          logger.debug('[Autoplay] Stopped.');\n          break;\n        // When in view and idle, start it.\n        case isInView && autoplayInstance.state === IntervalState.IDLE: {\n          autoplayInstance.start();\n          logger.debug('[Autoplay] Started.');\n          break;\n        }\n        // When in view and paused, resume it.\n        case isInView && autoplayInstance.state === IntervalState.PAUSED: {\n          autoplayInstance.resume();\n          logger.debug('[Autoplay] Resumed.');\n          break;\n        }\n      }\n    } else if (autoplayInstance.state !== IntervalState.IDLE) {\n      autoplayInstance.stop();\n      logger.info('[Autoplay] Stopped.');\n    }\n  }, [autoplay, isInView]);\n\n  /**\n   * Clearing any existing timeouts to avoid memory leaks, and clear event listener.\n   */\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(state.debounceTimeout);\n      autoplayInstance.stop();\n    };\n  }, []);\n\n  /**\n   * When the slide changes, clear any debounced timeouts, after the slide finishes, the\n   * autoplay resets.\n   */\n  React.useEffect(() => {\n    clearTimeout(state.debounceTimeout);\n    return () => {};\n  }, [controller.activeSlide]);\n\n  // NOTE: you *might* need to memoize this value\n  // Learn more in http://kcd.im/optimize-context\n  const value = {\n    state,\n    autoplayState: autoplayInstance.state,\n    debounce,\n    pause,\n    resume\n  };\n\n  return (\n    <AutoplayStateContext.Provider value={value}>\n      {children}\n    </AutoplayStateContext.Provider>\n  );\n}\n\nfunction useAutoplay() {\n  const context = React.useContext(AutoplayStateContext);\n\n  if (context === undefined) {\n    throw new Error('useAutoplay must be used within a AutoplayProvider');\n  }\n\n  return context;\n}\n\nexport { AutoplayProvider, useAutoplay };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}